语法
------
对象可以由两种方式生成:字面量和构造器
字面量语法如下:
```javascript
var myObj = {
  key: value
  //...
};
```
构造器方式如下:
```javascript
var myObj = new Object();
myObj.key = value;
```
两种方式生成的对象没有差别.唯一的不同是`字面量`方法你可以加一个或者多个键值对属性，而`构造器`方法，你只能一个一个的加属性。

`Note:`不推荐用构造器方法来生成对象，最好用字面量方法。

类型
---
对象是构建JS语言的基础类型，在JS中有6种基础类型。
- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `object`

`Note`: the simple primitives (string, number, boolean, null, and undefined) are not themselves objects.
`null`有时候指向一个对象类型，这是语言本身的bug，导致 `typeof null` 会返回 `"object"`，这是不对的（并且令人迷惑）.实际上，`null`就代表一种原始基础类型

"`everything in javascript is an object`是句普遍的错误的描述,这句话是不对的"

相对而言，还有一些特殊的对象子类型，我们可以将他们说成`complex primitives`

`function`是一种对象子类型(术语:callable object).Functions在JS被称为`first class`,他们原则上只是普通的对象(在语义上有可调用的行为)，所以他们可以像其他纯对象一样的使用。

Arrays也是一种带有额外行为的的对象。官方内容上Arrays比普通对象略结构化一些。（？）

#### Built-in Objects

其他一些对象子类型，通常只向一些内建对象，他们之中的一些，名字看起来在指名他们和他们的原始的类型，但是实际上他们的关系要复杂的多，我们马上将会探讨。
* `String`
* `Number`
* `Boolean`
* `Object`
* `Function`
* `Array`
* `Date`
* `RegExp`
* `Error`

These built-ins have the appearance of being actual types, even classes, if you rely on the similarity to other languages such as Java's `String` class.

但是在JS中，这些无疑仅仅就是內建的函数。每一个这样的函数都可以像构造器一样使用(`new anyFunction()`,章节2)，产生一个新的构造过的子类型对象。例如：
```javascript
var strPrimitive = 'I am a string';
typeof strPrimitive;                //"string"
strPrimitive instanceof String;     //false

var strObject = new String('I am a string');
typeof strObject;                   //"object"
strObject instanceof String;         //true

//检查对象的子类型
Object.prototype.toString.call( strObject );   //[object String]
Object.prototype.toString.call( 'i am a string' );   //[object String] 输出相同，为什么?？  -->后面
```
我们将在后面的章节了解`Object.prototype.toString...`是怎么工作的，简单来说，我们可以借用这个`toString()`方法来检测他们的内在类型。可以看到`strObject`实际上是`String`构造器生成的一个对象

基础值`"I am a string"`不是一个对象，他是一个基础的不可变的字面量值。要操作它，比如检查他的长度，获得他的单个字节内容等等，必须要有一个`String`对象。

幸运的是，JS在必要的时候会自动的将基础字符串类型转换成了一个`String`对象。这意味着不你需要显示的创建一个对象。多数的JS社区在没特殊要求下，优先考虑用字面量形式来创建，而不是构造器方式。

思考:
```js
var strPrimitive = 'I am a string';
console.log( strPrimitive.length );     //13
console.log( strPrimitive.charAt( 3 )); // "m"
```
在这两种情况下，我们在一个原始字符串中调用一个属性或者方法，引擎(是什么引擎?)自动将于是字符串转成`String`对象，所以我们可以调用属性和方法

数字和布尔类型相似

`null`和`undefined`没有对象包装形式，只有他们的原始值。相对而言，`Date`类型的值只通过他们的构造器来生成，因为他没有字面量形式。

`Object`s, `Array`s, `Function`s和 `RegExp`s(正则表达式)都是对象，不管他是用字面量还是构造器生成的。构造器形式在某些情况下比字面量形式要能提供更多的选择参数。但是字面量仍然是用的最广泛的**只在你需要的额外的选项时才用构造器形式**

`Error`对象很少在代码中显示的创建，但是当异常抛出时常常会自动的产生。它可以通过`new Error(...)`来创建，用的很少。

#### 内容

像之前我们提及到的一样，对象的内部是由很多任意类型的值组成的，我们管他们叫属性。

首先得强调的是，我们说的那些指向存在对象里面的值的内容，仅仅是表象。引擎通过一些implementation-dependent方式来存储值，很可能不会存在对象里面。存在对象里面的是他们属性的名称，这些名称的表现像指针(引用）,指向保存真正值的位置。

思考：
```js
var myObject = {
  a: 2
};
myObject.a;     //2

myObject['a']   //2
```
我们可以通过`.a`或者`["a"]`来获取它的值,`.a`表明是属性的访问，`["a"]`表明是键值访问。一般来说都采用`.a`方式

这两种方式的主要区别是，`.`操作符后面需要一个跟属性名称相同的`标识符`，而`[".."]`语法可以接受一切UTF-8/unicode字符串作为他的属性，例如一个属性名为`Super-Fun`,你只能用`["Super-Fun"]`去访问，因为`Super-Fun`不是一个合法的`标识符`属性名。

另外，由于`[".."]`语法用字符串的值来指明位置，那么表明我们可以用程序语言来构建这个字符串例如。。
```js
var wantA = true;
var myObject = {
  a: 2
};

var idx;

if (wantA) {
  idx = "a";
}

//later

console.log(myObject[idx]); //2
```

在对象中，属性名**永远**是字符串，如果你用其他非字符串作为他的属性，那么他将转化为字符串，数字也是一样，所以不要把**数组中数字的用法**和**对象中数字的用法**混淆了。

```js
var myObject = { };

myObject[true] = "foo";
myObject[3] = "bar";
myObject[myObject] = "baz";

myObject["true"];				// "foo"
myObject["3"];					// "bar"

//Focus
myObject["[object Object]"];	// "baz"
```

#### 计算属性名

刚刚讨论的`myObject[..]`属性访问语法可以用可计算的表达式来作为他的键名，像`myObject[prefix + name]`,但是当你用字面量形式创建对象时帮助不是很大。

ES6添加了**可计算的属性名称**,对象字面量中你可以用指定的表达式来做键。
```js
var prefix = "foo";

var myObject = {
  [prefix + "bar"]: "hello",
  [prefix + "baz"]: "world"
};

myObject["foobar"]; //hello
myObject["foobaz"]; //hello
```
可计算属性名最普遍的用法是ES6中的`Symbol`，我们不会在这里详细介绍。

#### 属性VS方法

当谈到对象中的属性访问是函数时，有些开发者喜欢搞出点区别来，因为很容易想到这个函数是属性这个对象的，在其他语言中，经常可以听到他们把属于对象(类)的函数被称作是方法。方法访问相对于属性访问。

**规范中也作出了相同的区别**,interestingly

严格来说，函数从不"属于"对象，所以将访问对象中的函数成为方法似乎是一种语义上的延展。

没错，有些函数拥有`this`引用，有时候这个`this`引用是来自对象。但是这个用法真的不能让这个函数比其他函数更像"方法"，而且考虑到`this`是在运行时动态绑定的，所以函数和对象中的关系是不明确的。

每当你访问一个对象中的属性，那就是**属性访问**，不管返回给你的是什么值。如果你在属性访问中获得的指是一个函数，在这点上它不是一个方法。属性访问返回一个函数没有什么特别的地方，跟其他类型的值是一样的。

例如
```js
function foo() {
  console.log("foo");
}

var someFoo = foo; //variable reference to 'foo'

var myObject = {
  someFoo: foo
};

foo; //function foo(){...}

someFoo; //function foo(){...}

myObject.someFoo; //function foo(){...}
```
`someFoo`和`myObject.someFoo`对这个函数的引用是独立的，既没有指明函数有什么特殊的地方，也不指明它属于哪一个对象。如果上面的`foo()`函数中定义了一个this引用，那么在`myObject.someFoo`隐式绑定的引用和函数中的引用是唯一一个可被观察的不同。引用对 **函数被称为方法** 这一说法没有实际的支持意义。

**也许有人会反对说** 函数是在运行时的调用而 *成为方法* 的,而不是定义的时候.这种解释也是一种语义上的扩展而已。

最靠谱的结论可能是，函数和方法在Javascript中是可以相互替换的。

**注意:** ES6 增加了 `super`引用，通常在类中使用。`super`的表现(静态绑定，而不像`this`是在运行时绑定)表明，当一个函数绑定在`super`上时，它更像一个方法而不是函数。但是，这些也仅仅是语义上细微的差别而已。

甚至当你在对象字面量里定义了一个函数表达式作为对象的一部分，这个函数也不会属于这个对象。 仅仅是对相同函数的多个引用而已:

```js
var myObject = {
  foo: function foo(){
    console.log('foo');
  }
};

var someFoo = myObject.foo;

someFoo; // function foo() {...}

myObject.foo;  //function foo() {...}

```

**注意:** 在章节6中，我们会介绍 ES6中是怎样在对象字面量中声明函数的。

#### 数组
数组也使用`[ ]`这个访问形式，但是像前面所说的一样，他们有更结构化的组织来决定怎样存和存到哪里的(尽管对存储的值得类型依然不做限制).数组用 `纯数字索引`,意味着值都是存在一些坐标位置上，经常叫做`索引`, 在非负整数上，比如 `0`或者`42`。

```js
var myArray = [ "foo", 42, "bar"];

myArray.length; // 3

myArray[0];  // 'foo'

myArray[2];  // 'bar'
```

数组是对象，所以尽管每一个索引都是正整数，*你还是可以加属性给数组*

```js
var myArray = [ "foo", 42, "bar"];

myArray.baz = "baz";

myArray.length; // 3

myArray.baz; // "baz"
```
注意，加属性不会影响数组的`长度`。

你可以用数组来作为一个纯的键值对 对象，不加数字索引给它，但是这不是个好的主意，因为数组在正常使用时有特定的行为和优点，就像纯对象一样。用对象来存键值对，用数组索引来存值。

**注意:** 如果你想给一个数组加属性，但是这个属性名看起来像数字，那它将作为一个数字索引。
```js
var myArray = [ "foo", 42, "bar"];

myArray["3"] = "baz";

myArray.length; // 4

myArray[3]; // "baz"
```
#### 复制对象
复制对象有一点点复杂， 因为还不是很明确该用哪一种算法来实现复制。

例如，有如下对象:
```js
function anotherFunction() { /*....*/ }

var anotherObject = {
  c: true
};

var anotherArray = [];

var myObject = {
  a:2 ,
  b: anotherObject,  // 引用， 不是复制
  c: anotherArray,   // 还是引用
  d: anotherFunction
};

anotherArray.push( anotherObject, myObject);
```
到底该怎么表述`myObject`的复制呢？

首先，我们要先回答是`深复制`还是`浅复制`。 `浅复制`会将`myObject`中`a`的值复制，而 `b`, `c`, `d`仅仅只是引用原来的对象(`myObject`)。 `深复制`会将`myObject`中所有的值都复制过来，但是我们又发现， `anotherArray`也有`anotherObject`和`myObject`的引用，所有他们也要复制一遍，而不是引用。现在，我们将无限的复制下去，因为我们有循环引用。

我们该检测循环引用，然后仅仅停止遍历(让底层的对象不完全的复制)?或者我们直接报错？又或者两者之间的什么方法？

而且。
