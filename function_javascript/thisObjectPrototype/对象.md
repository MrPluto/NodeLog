语法
------
对象可以由两种方式生成:字面量和构造器
字面量语法如下:
```javascript
var myObj = {
  key: value
  //...
};
```
构造器方式如下:
```javascript
var myObj = new Object();
myObj.key = value;
```
两种方式生成的对象没有差别.唯一的不同是`字面量`方法你可以加一个或者多个键值对属性，而`构造器`方法，你只能一个一个的加属性。

`Note:`不推荐用构造器方法来生成对象，最好用字面量方法。

类型
---
对象是构建JS语言的基础类型，在JS中有6种基础类型。
- `string`
- `number`
- `boolean`
- `null`
- `undefined`
- `object`

`Note`: the simple primitives (string, number, boolean, null, and undefined) are not themselves objects.
`null`有时候指向一个对象类型，这是语言本身的bug，导致 `typeof null` 会返回 `"object"`，这是不对的（并且令人迷惑）.实际上，`null`就代表一种原始基础类型

"`everything in javascript is an object`是句普遍的错误的描述,这句话是不对的"

相对而言，还有一些特殊的对象子类型，我们可以将他们说成`complex primitives`

`function`是一种对象子类型(术语:callable object).Functions在JS被称为`first class`,他们原则上只是普通的对象(在语义上有可调用的行为)，所以他们可以像其他纯对象一样的使用。

Arrays也是一种带有额外行为的的对象。官方内容上Arrays比普通对象略结构化一些。（？）

#### Built-in Objects
其他一些对象子类型，通常只向一些内建对象，他们之中的一些，名字看起来在指名他们和他们的原始的类型，但是实际上他们的关系要复杂的多，我们马上将会探讨。
* `String`
* `Number`
* `Boolean`
* `Object`
* `Function`
* `Array`
* `Date`
* `RegExp`
* `Error`

These built-ins have the appearance of being actual types, even classes, if you rely on the similarity to other languages such as Java's `String` class.

但是在JS中，这些无疑仅仅就是內建的函数。每一个这样的函数都可以像构造器一样使用(`new anyFunction()`,章节2)，产生一个新的构造过的子类型对象。例如：
```javascript
var strPrimitive = 'I am a string';
typeof strPrimitive;                //"string"
strPrimitive instanceof String;     //false

var strObject = new String('I am a string');
typeof strObject;                   //"object"
strObject instanceof String;         //true

//检查对象的子类型
Object.prototype.toString.call( strObject );   //[object String]
Object.prototype.toString.call( 'i am a string' );   //[object String] 输出相同，为什么?？  -->后面
```
我们将在后面的章节了解`Object.prototype.toString...`是怎么工作的，简单来说，我们可以借用这个`toString()`方法来检测他们的内在类型。可以看到`strObject`实际上是`String`构造器生成的一个对象

基础值`"I am a string"`不是一个对象，他是一个基础的不可变的字面量值。要操作它，比如检查他的长度，获得他的单个字节内容等等，必须要有一个`String`对象。

幸运的是，JS在必要的时候会自动的将基础字符串类型转换成了一个`String`对象。这意味着不你需要显示的创建一个对象。多数的JS社区在没特殊要求下，优先考虑用字面量形式来创建，而不是构造器方式。

考虑一下:
```js
var strPrimitive = 'I am a string';
console.log( strPrimitive.length );     //13
console.log( strPrimitive.charAt( 3 )); // "m"
```
在这两种情况下，我们在一个原始字符串中调用一个属性或者方法，引擎(是什么引擎?)自动将于是字符串转成`String`对象，所以我们可以调用属性和方法

数字和布尔类型相似

`null`和`undefined`没有对象包装形式，只有他们的原始值。相对而言，`Date`类型的值只通过他们的构造器来生成，因为他没有字面量形式。

`Object`s, `Array`s, `Function`s和 `RegExp`s(正则表达式)都是对象，不管他是用字面量还是构造器生成的。构造器形式在某些情况下比字面量形式要能提供更多的选择参数。但是字面量仍然是用的最广泛的**只在你需要的额外的选项时才用构造器形式**

`Error`对象很少在代码中显示的创建，但是当异常抛出时常常会自动的产生。它可以通过`new Error(...)`来创建，用的很少。

####内容
像之前我们提及到的一样，对象的内部是由很多任意类型的值组成的，我们管他们叫属性。

首先得强调的是，我们说的那些指向存在对象里面的值的内容，仅仅是表象。引擎通过一些implementation-dependent方式来存储值，很可能不会存在对象里面。存在对象里面的是他们属性的名称，这些名称的表现像指针(引用）,指向保存真正值的位置。

考虑一下：
```js
var myObject = {
  a: 2
};
myObject.a;     //2

myObject['a']   //2
```
