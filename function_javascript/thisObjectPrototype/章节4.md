# 章节4: Mixing (up) "Class" Objects

跟上上一章节的对对象的探索，我们现在将转向 `面向对象编程(OOP)`.在我们探索类的机制(实例化，继承，多态)之前，我们先看看 `class orientation `这种设计模式.

我们会看到对象在JS中的机制跟上面这些概念并不是完全匹配.很多JS开发者都在不断的战胜这些挑战.

**注意:** 我们将画很多时间(一半章节)来讲`面向对象编程`理论. 我们会在后半部分将这些理念用JS代码联系起来.

### 类的概念 (Class Theory)

"类/继承"描述了一个确切的代码组织和架构--在我们的软件领域中将生活中真实存在的问题进行建模.

OO或者面向类编程强调，当数据被操作时，它本质上是有相关的行为的(类型的不同行为可能不同). 所以合适的设计师将数据和行为打包(封装)在一起.这在传统计算机科学中也被叫做数据结构

例如,表示一个单词或者句子的一连串字符通常叫做`string`. 这些字符就是数据.但是我们并不只关心数据，我们更想去用数据来做些什么,所以一些可以应用到数据上(计算长度，添加数据，搜索等等)的行为就被设计成`String`类中的方法.

 所以给定的字符串都是`String`类的实例，这以为着它是一个将数据和我们可以使用的函数绑在一起的集合.

 Classes also imply a way of *classifying* a certain data structure. The way we do this is to think about any given structure as a specific variation of a more general base definition.


 例子. 一辆`汽车`可以被描述成是更普遍的类的一种特殊实现，例如`交通工具`

 我们在软件中将它们建模成`汽车`类和`交通工具`类.

 `交通工具`可能定义了动力(引擎等等)，载客能力或者其他,可能都是行为. 我们定义`交通工具`的所有东西在不同类型的交通工具中都是存在的(比如飞机，轮船或者汽车).

 在我们的软件中，对不同类型的交通工具，不停的重新定义基础的属性(例如载客能力)是没有意义的.相反的，我们只在`交通工具`类中定义一次，然后在我们定义`汽车`的时候指名它继承从`交通工具`类中继承基本的定义. `汽车`的定义本称作是特例化`交通工具`的定义.

 `交通工具`和`汽车`通过方法来共同的定义行为,实例中的数据可能是像特定汽车的唯一VIN码这种.

 另一个关键的概念是多态，它被描述为，父类中定义的方法可以在子类中重写，从而让它更具体化.实际上，多态让我们在基础行为中引用重写的行为.？？？

 类理念强烈建议父类和子类使用相同的方法名来抽象行为，以便子类重写父类行为(不同的实现).我们会在后面看到，在JS代码中做这个将是选择写挫败和脆弱的代码.


### 类设计模式 (Class Design Pattern)
你可能从来没想过类是一种设计模式，因为更常见的是关于面向`面向对象设计模式`,比如`迭代器`,`观察者`,`工厂`,`单例`等等.我们这么将，所有的高级设计模式的实现都是以面向对象的类机制来实现的.就像面向对象是所有代码的基础.

取决与你在编程方面的学习积累，你可能听到过过程程序设计，它仅仅由很多的函数调用组成，没有任何的高级抽象.你可能学习到过，类是一种合适的方式，它可以将杂乱的代码变成有组织有条理的代码.

当然，如果你有一些函数式编程的经验，你可能知道类仅仅就是一种普通的设计模式而已.但对大多数人来讲，第一时间他们想到的是，类到底是代码的基础，还是代码上层的一种可以选择的抽象.

一些语言并不让你有很多选择(例如Java,所有的都是类). 其他像C/C++或者PHP，他们同时支持面向过程和面向对象的语法.

### Javascript 类
在这方面Javascript是怎样做的呢？ JS很长一段时间内都有一些像类的语法(`new` `instanceof`), 到了ES6，又添加了 `class`关键字.

但是这就说明了Javascript 有类么 ？  答案是:**不是的**

因为类是种设计模式，你可以实现绝大部分功能都近似的类. JS尝试通过提供类似类的语法来满足大部分普通的设计需求.

尽管我们有类似类的语法，但是 Javascript的机制却好像不鼓励你使用 *类设计模式*,因为在底层，你构建的程序实际跑起来是跟你的想象不同的. 语法糖和JS类的库一直在将底层如何工作隐藏起来，但是马上你就会发现，你在其他语言中使用的类跟在JS中的不同.

总结来说，类是一种可选的设计模式，你可以选择在JS中用不用它.由于很多开发者很亲近面向类的软件设计，我们将在剩下的内容中探索JS是如何让它有类的感觉的，以及我们实践中的痛点是什么.

### 类机制 (Class Mechanics)
在很多面向类的语言中，他们的标准库提供了一种`栈(stack)`数据结构(push,pop.etc)来作为`stack`类.这个类内部有很多存储数据的变量，也有很多类提供的可访问的行为(方法),它让你的代码可以和数据交互.

但是在这种语言中，你并不是直接操作`stack`(除非创建一个 **静态** 的类成员引用). `stack`类仅仅是对栈如何工作的一种抽象解释,但是它本身不是一个简单的"stack". 你必须先实例化`stack`类，然后再操作具体的数据结构.

### 构建 (Building)
对类和实例的经典比喻来源于建筑施工

一个建造师计划了一个建筑所有的特征: 宽度，高度，窗户的数量和位置，甚至是墙面和屋顶的材料类型. 他并不关心这个建筑建在哪里,会建多少个相同的.

他也不关心建筑内部有些什么--家具，墙纸，顶扇等等--他只管用什么类型的结构来容纳它们.

他设计的建筑蓝图仅仅是为了一座建筑.图纸并没有构成我们可以走进去坐下来的建筑.我们需要一个建造师来完成这个建筑.建造师会拿着图纸，按照图纸来建造这个建筑. 现实意义上，他在将图纸上的特征变成实际上的建筑.

一旦结束，这个建筑就是这张建筑图纸的一个实例，希望这个建筑没搞砸.然后建造可以换一个地方再造一座.

建筑和建筑图纸之间的关系是间接的.你可以审查这个图纸来理解建筑的结构是怎样的, 直接检查这个建筑的所有部分是不足的.但是如果你想开一扇门，你就得进入建筑本身，图纸仅仅只画出了门应该在哪里.

一个类就是一张图纸. 我们要获得一个我们可以交互的对象，我们必须要通过类来创建一些东西. 这个设计的结果就是返回一个对象,通常叫做`实例`, 我们可以直接调用它的方法，也可以直接访问任何公开的数据.

**这个对象是** 用有全部特征的类的一个 **拷贝(实例)**

<img src="fig1.png">

### 构造器 (Constructor)
类的实例是通过类的一个特殊的方法构造的, 通常方法的名字和类是相同的，它就做 *构造器(constructor)*. 这个方法最明显的工作是初始化这个实例所需要的所有信息(状态)

```js
class CoolGuy {
  specialTrick = nothing

  CoolGuy( trick ) {
    specialTrick = trick
  }

  showOff() {
    output( "here's my trick: ", specialTrick )
  }
}
```
要产生一个 `CoolGuy` 实例，我们要调用类的构造器:
```js
Joe = new CoolGuy( 'Jumping rope' )

joe.showOff() //here's my trick: Jumping rope
```
注意 `CoolGuy` 类有一个构造器 `CoolGuy()`，我们执行`new CoolGuy(...)` 时实际上会调用它. 我们通过构造器得到一个对象(类实例)，然后我们可以调用`showOff()`方法,来打印我们的绝招

*很明显，跳绳让 Joe 变得很酷 😢*

类的构造器属于这个类，通常和类的名字相同. 同样，构造器需要通过`new`来调用，从而让语言引擎知道你想构造一个新的类实例

### 类继承 (Class Inheritance)
在面向类的语言中，你不仅可以定义一个可以被实例化的类，同样也可以定义一个继承自第一个类的另外一个类.

第二的类通常叫做子类，而第一个类叫做父类. 这些术语的比喻很显然是来自父亲和儿子,尽管这些比喻有些延伸.

当一个父亲有一个生物学上的儿子，父亲的基因特征将会被复制到儿子身上.显然，在绝大多数生物繁殖系统中，会有两个父辈的基因混合. 但是为了这个比喻的目的，我们假设只有一个父辈.

一旦儿子存在，他讲是独立于父辈的. 儿子很大程度上受继承父辈的影响,但是它是独特的不同的. 如果一个儿子的头发变成了红色，这不意味着父辈的头发会自动变成红色.

简单来说，一旦子类被定义，它和父类就是独立的不同类了. 这类保存着来自父辈行为的原始拷贝,但是它可以重写这些继承来的行为，也可以重新定义新的行为.

我们现在说的是父类子类，它们并不是物理层面的东西. 这也是比喻成父亲和儿子的一点困惑,因为我们实际上该说事父类像父辈的DNA，而子类像子辈的DNA.  We have to make (aka "instantiate") a person out of each set of DNA to actually have a physical person to have a conversation with.

让我先抛开生物学上的父辈和子辈,来通过一个微小的例子(不同类型的交通工具)来看继承. 这是一个经典的比喻来理解继承.

我们回顾一下之前提到的`Vehicle`和`Car`. 考虑下面的继承类的伪代码:
```js
class Vehicle {
  engines = 1

  ignition() {
    output('Turning on my engine')
  }

  drive() {
    ignition()
    output('Steering and moving forward')
  }
}

class Car inherits Vehicle{
  wheels = 4

  drive(){
    inherited: drive()
    output("Rolling on all", wheels, 'wheels')
  }
}

class SpeedBoat inherits Vehicle {
	engines = 2

	ignition() {
		output( "Turning on my ", engines, " engines." )
	}

	pilot() {
		inherited:drive()
		output( "Speeding through the water with ease!" )
	}
}
```
**注意:** 为了代码的清晰简洁，我们略去了类的构造器.

我们定义 `Vehicle` 类有一个引擎，一种点火启动方式，一种驾驶方式，你不必将它定义成一个完备的通用的'交通工具'，在这里它只不过是一种抽象的概念

然后我们定义两种具体的交通工具: `Car`和`SpeedBoat`,他们都继承了`Vehicle`的通用特征，但是他们各自定制了适合它们自己的特征. 一辆车有4个轮子，一个快艇有2个引擎，意味着它需要额外的方式来启动引擎.

### 多态性 (Polymorphism)

`Car`定义了它自己的`drive()`方法，通过重写继承自`Vehicle`的`drive()`方法.但是注意，`Car`的`drive()`方法调用了`inherited:drive()`,这表明`Car`可以引用它继承的重写前的`drive()`. `SpeedBoat`的`pilot()`方法通过有一个对它继承的的`drive()`方法的引用.

这种技术叫做'多态性'， 或者'虚拟多态性'. 就我们现在关注的点来讲，我们将叫他'相关多态性'.

多态的概念比我们现在所探究的要广泛的多，但是我们现在'相关的'语义参考了一个特别的部分: 就是任何一个方法都可以引用其更高级继承链中的另一个方法(不管名字是相同还是不同).我们之所以讲'相关的',是因为我们并没有定义我们想要访问得继承层级,也没有从本质上说'look one level up'来引用相关的的层级

在很多语言中，`super`关键字代替了这个例子中的`inherited:`,这依靠了`super class`的概念，它是现在这个类的父亲/祖先.

另一个多态的概念是，一个方法名字在不同的层级继承关系中可以有不同的定义，当方法被调用时，这些定义的方法会被自动并且合适的选用.

我们在上面的例子中看到这种行为出现了两次: `drive()`在`Vehicle`和`Car`中都定义了，`ignition()`在`Vehicle`和`SpeedBoat`中都定义了.

**注意:** 传统的面对类语言中通过`super`来在子类的构造方法中直接引用它父类的构造方法.这无疑你对的因为真正的类中，构造方法是属于类的.但是在JS中，这是相反的--类属于构造器这一想法更合适(`Foo.prototype...`类型的引用).因为在JS中，子类和父类的关系仅仅仅仅存在于两个来自相应构造器的`.prototpe`对象,构造器他们本身是没有直接关系的.因此没有简单的方法来将这个关联到那个(ES6的`class`通过`super`解决了这个问题).

我们可以通过`ignition()`方法看到一个有趣的多态实践. 在`pilot()`中,有一个继承自`Vehicle`版本的`drive()`.但是这个`drive()`仅仅会通过名字来引用`ignition()`方法 (不是相关引用)

那么语言引擎会调用哪一个版本的`ignition()`方法呢？ 是来自`Vehicle`的还是来自`SpeedBoat`呢？ **引擎将会调用`SpeedBoat`中的`ignition()`方法**, 如果你实例化`Vehicle`类本身，那么在它的`drive()`方法中调用的`ignition()`才是`Vehicle`定义的

换句话说， `ignition()`的具体定义取决于你引用的是那一个实例.

当类被继承时，对这些类来说，他们有一种方式来相对的引用到他们继承的类. 这个引用通常叫做`super`

<img src='fig1.png'>
